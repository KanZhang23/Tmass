#ifndef NPSTAT_KDEFILTERND_HH_
#define NPSTAT_KDEFILTERND_HH_

/*!
// \file KDEFilterND.hh
//
// \brief KDE on a regularly spaced multivariate grid with symmetric kernels
//
// If you don't expect to perform cross-validation or bandwidth scans,
// ConstantBandwidthSmootherND class might be a more convenient choice.
//
// Author: I. Volobouev
//
// December 2011
*/

#include "npstat/stat/AbsPolyFilterND.hh"

#include "npstat/nm/ArrayND.hh"
#include "npstat/nm/ConvolutionEngineND.hh"

namespace npstat {
    /**
    // This class performs kernel density estimation on a regularly spaced
    // multivariate grid with arbitrary, tabulated symmetric kernels
    */
    template <unsigned MaxDeg>
    class KDEFilterND : public AbsPolyFilterND
    {
    public:
        enum {deg_size = MaxDeg};

        /**
        // Main constructor. The arguments are as follows:
        //
        //  taper      -- Damping factors for each polynomial degree
        //                (starting with the 0th order term). This can be
        //                NULL in which case it is assumed that all
        //                factors are 1.
        //
        //  maxDegree  -- Maximum degree of the polynomials. The value
        //                must not exceed the "MaxDeg" template parameter.
        //                The length of the "taper" array (if not NULL)
        //                must be equal to maxDegree + 1. Note that the same
        //                filter will be produced using an even degree N and
        //                an odd degree N+1.
        //
        //  weight     -- The array of weights. This is just one hyperoctant
        //                corresponding to positive directions in all
        //                dimensions. The remaining part of the kernel
        //                is generated by reflections.
        //
        //  engine     -- The engine to use for convolutions. This object
        //                will not make its own copy of the engine. It is
        //                the responsibility of the user to ensure that
        //                the lifetime of the engine exceeds the lifetime
        //                of this object. It is assumed that the size
        //                of the arrays to filter will be two times smaller
        //                in each dimension than what is expected by the
        //                engine. Note that dimensionalities of weight
        //                array must not exceed data dimensionalities.
        //
        //  id         -- Filter slot number in the engine. Each filter
        //                used with this particular engine must be provided
        //                with a unique slot id.
        //
        //  workBuffer -- Buffer array for various calculations. Must have
        //                the same shape as the convolution engine. Will
        //                not be copied internally. Must exist while this
        //                object operates.
        //
        //  mirror     -- If true, the data will be mirrored at the
        //                boundaries to reduce the edge effects.
        */
        template <typename T, unsigned StackLen, unsigned StackDim>
        KDEFilterND(const double* taper, unsigned maxDegree,
                    const ArrayND<T,StackLen,StackDim>& weight,
                    ConvolutionEngineND& engine, unsigned long id,
                    ArrayND<double>& workBuffer, bool mirror=true);

        virtual ~KDEFilterND();

        //@{
        /** Inspect object properties */
        inline unsigned dim() const {return dataShape_.size();}
        inline unsigned maxDegree() const {return taper_.size() - 1U;}
        inline ArrayShape dataShape() const {return dataShape_;}
        double taper(unsigned degree) const;
        inline bool mirrorsData() const {return mirrorData_;}
        //@}

        //@{
        /**
        // Contribution of a single point into the density estimate
        // at that point (not normalized). This is needed for various
        // leaving-one-out cross validation procedures.
        */
        double selfContribution(const unsigned* index,
                                unsigned indexLen) const;
        double linearSelfContribution(unsigned long index) const;
        //@}

        /** Check the compatibility of an array with the filter */
        template <typename T, unsigned StackLen, unsigned StackDim>
        inline bool isCompatible(const ArrayND<T,StackLen,StackDim>& in) const
            {return in.isCompatible(dataShape_);}

        /** The method which performs the filtering */
        template <typename Tin, unsigned StackLen, unsigned StackDim,
                  typename Tout, unsigned StackLen2, unsigned StackDim2>
        void filter(const ArrayND<Tin,StackLen,StackDim>& in,
                    ArrayND<Tout,StackLen2,StackDim2>* out) const;

        /**
        // This method is included for compatibility with LocalPolyFilterND.
        // For KDE, there is no difference between "convolve" and "filter".
        */
        template <typename Tin, unsigned StackLen, unsigned StackDim,
                  typename Tout, unsigned StackLen2, unsigned StackDim2>
        inline void convolve(const ArrayND<Tin,StackLen,StackDim>& in,
                             ArrayND<Tout,StackLen2,StackDim2>* out) const
            {this->filter(in, out);}

    private:
        KDEFilterND();
        KDEFilterND(const KDEFilterND&);
        KDEFilterND& operator=(const KDEFilterND&);

        ArrayShape dataShape_;
        mutable ArrayShape idxBuffer_;
        ConvolutionEngineND* engine_;
        std::vector<double> taper_;
        unsigned long slotId_;
        ArrayND<double>* buf_;
        double filterAtTheCenter_;
        ArrayND<double>* selfContrib_;
        bool mirrorData_;

        void calculateSelfContribution(const ArrayND<double>& filter);
    };
}

#include "npstat/stat/KDEFilterND.icc"

#endif // NPSTAT_KDEFILTERND_HH_
